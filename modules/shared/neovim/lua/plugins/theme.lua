local M = {}

-- Cache the palette loader module
local palette_loader = nil

local function get_palette()
  -- Load the palette loader module (cached after first load)
  if not palette_loader then
    local ok, loader = pcall(require, "theme.palette")
    if not ok then
      vim.notify("Theme palette loader not found, using fallback", vim.log.levels.WARN)
      return {
        base = "#191724",
        mantle = "#1f1d2e",
        surface = "#26233a",
        overlay = "#403d52",
        text = "#e0def4",
        subtext0 = "#908caa",
        subtext1 = "#6e6a86",
        muted = "#6e6a86",
        primary = "#c4a7e7",
        secondary = "#ebbcba",
        red = "#eb6f92",
        orange = "#f6c177",
        yellow = "#f6c177",
        green = "#9ccfd8",
        cyan = "#31748f",
        blue = "#31748f",
      }
    end
    palette_loader = loader
  end
  
  -- Get current palette (will read from JSON if available)
  return palette_loader.get()
end

local function apply_theme()
  local palette = get_palette()

  -- Use the dynamic colorscheme generated by Nix
  local ok, err = pcall(vim.cmd.colorscheme, 'dynamic')
  if not ok then
    vim.notify("Failed to load dynamic colorscheme: " .. tostring(err), vim.log.levels.ERROR)
    vim.notify("Falling back to default colorscheme", vim.log.levels.WARN)
    vim.cmd.colorscheme("habamax")
    return
  end
  
  -- Additional plugin-specific highlights that might not be in the colorscheme
  local plugin_highlights = {
    -- Bufferline
    BufferLineFill = { bg = palette.base },
    BufferLineBackground = { fg = palette.muted, bg = palette.mantle },
    BufferLineBufferSelected = { fg = palette.text, bg = palette.surface, bold = true },
    BufferLineIndicatorSelected = { fg = palette.primary, bg = palette.surface },
    
    -- WhichKey
    WhichKey = { fg = palette.primary },
    WhichKeyGroup = { fg = palette.cyan },
    WhichKeyDesc = { fg = palette.text },
    WhichKeySeparator = { fg = palette.muted },
    WhichKeyFloat = { bg = palette.surface },
    WhichKeyBorder = { fg = palette.overlay, bg = palette.surface },
    
    -- Noice
    NoiceCmdlinePopup = { fg = palette.text, bg = palette.surface },
    NoiceCmdlinePopupBorder = { fg = palette.overlay, bg = palette.surface },
    NoiceCmdlineIcon = { fg = palette.primary },
    NoiceConfirm = { fg = palette.text, bg = palette.surface },
    NoiceConfirmBorder = { fg = palette.overlay, bg = palette.surface },
    
    -- Flash
    FlashLabel = { fg = palette.base, bg = palette.primary, bold = true },
    FlashMatch = { fg = palette.yellow, bold = true },
    FlashCurrent = { fg = palette.orange, bold = true },
    
    -- Trouble
    TroubleNormal = { fg = palette.text, bg = palette.base },
    TroubleText = { fg = palette.text },
    TroubleCount = { fg = palette.primary, bold = true },
    TroubleCode = { fg = palette.subtext0 },
    
    -- Indent Blankline
    IblIndent = { fg = palette.overlay },
    IblScope = { fg = palette.primary },
    
    -- Todo Comments
    TodoBgFix = { fg = palette.base, bg = palette.red, bold = true },
    TodoBgHack = { fg = palette.base, bg = palette.orange, bold = true },
    TodoBgNote = { fg = palette.base, bg = palette.cyan, bold = true },
    TodoBgPerf = { fg = palette.base, bg = palette.blue, bold = true },
    TodoBgTest = { fg = palette.base, bg = palette.green, bold = true },
    TodoBgTodo = { fg = palette.base, bg = palette.yellow, bold = true },
    TodoBgWarn = { fg = palette.base, bg = palette.orange, bold = true },
    
    -- Lazy
    LazyNormal = { fg = palette.text, bg = palette.base },
    LazyButton = { fg = palette.text, bg = palette.surface },
    LazyButtonActive = { fg = palette.base, bg = palette.primary, bold = true },
    LazyH1 = { fg = palette.base, bg = palette.primary, bold = true },
    LazyH2 = { fg = palette.primary, bold = true },
    LazyProp = { fg = palette.cyan },
    LazyValue = { fg = palette.green },
  }

  for group, opts in pairs(plugin_highlights) do
    vim.api.nvim_set_hl(0, group, opts)
  end
end

function M.setup()
  apply_theme()
  
  -- Watch for theme changes by monitoring the symlink
  local config_home = vim.fn.expand(os.getenv("XDG_CONFIG_HOME") or "~/.config")
  local palette_file = config_home .. "/current-theme/nvim-palette.lua"
  
  -- Initialize tracking
  M._initialized = true
  local stat = vim.loop.fs_stat(palette_file)
  if stat then
    M._last_theme_mtime = stat.mtime.sec
  end
  
  -- Create a timer that checks for theme file changes
  local timer = vim.loop.new_timer()
  timer:start(1000, 1000, vim.schedule_wrap(function()
    local current_stat = vim.loop.fs_stat(palette_file)
    if current_stat then
      local current_mtime = current_stat.mtime.sec
      if M._last_theme_mtime and M._last_theme_mtime < current_mtime then
        M._last_theme_mtime = current_mtime
        -- Reload theme immediately
        palette_loader = nil
        apply_theme()
        vim.notify("Theme updated!", vim.log.levels.INFO)
      end
    end
  end))
  
  -- Also check on focus/buffer enter as backup
  vim.api.nvim_create_autocmd({"FocusGained", "BufEnter"}, {
    group = vim.api.nvim_create_augroup("ThemeReload", { clear = true }),
    callback = function()
      local stat_now = vim.loop.fs_stat(palette_file)
      if stat_now then
        local mtime = stat_now.mtime.sec
        if M._last_theme_mtime and M._last_theme_mtime < mtime then
          M._last_theme_mtime = mtime
          palette_loader = nil
          apply_theme()
        end
      end
    end,
  })
  
  -- Keymap to manually reload theme
  vim.keymap.set("n", "<leader>uC", function()
    palette_loader = nil
    apply_theme()
    vim.notify("Theme reloaded!", vim.log.levels.INFO)
  end, { desc = "Reload colorscheme" })
  
  -- User command for theme reload
  vim.api.nvim_create_user_command("ThemeReload", function()
    palette_loader = nil
    apply_theme()
    vim.notify("Theme reloaded!", vim.log.levels.INFO)
  end, { desc = "Reload the current theme" })
end

return M